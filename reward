ğŸ“Œ What Is an Emission Schedule?

An emission schedule controls how many tokens are released as rewards over time, based on time or activity. Itâ€™s often used to:

âœ” Reward early participation more heavily
âœ” Gradually reduce emissions to avoid inflation
âœ” Tie emissions to milestones or usage
âœ” Include dynamic adjustments (e.g., activity-based boosts or governance-controlled parameters) 
Blockchain App Factory

For example, Solanaâ€™s own approach to inflation starts with a high reward rate and gradually tapers toward a lower long-term rate â€” a principle you can adapt for DACIT. 
OKX

ğŸ§  Emission Logic Strategy

Your reward schedule might look like:

ğŸ“ Epoch-Based Emission â€” Rewards minted per epoch (Solana epoch or custom time interval)
ğŸ“ Decay / Tapering â€” Emissions decrease over milestones (e.g., halving every N epochs)
ğŸ“ Activity Adjustment â€” Increase or decrease emissions based on participation metrics
ğŸ“ Governance Controls â€” Parameters adjustable via token holder voting

This modular approach lets your tokenomics evolve over time.

ğŸ›  On-Chain Reward Schedule Module (Anchor)

Below is an Anchor Rust module that implements an evolving schedule with several common patterns (linear decay, epoch milestones, and governance overrides).

1)ï¸âƒ£ Reward Schedule Account
use anchor_lang::prelude::*;

#[account]
pub struct EmissionSchedule {
    pub initial_rate: u64,      // base tokens per epoch/unit time
    pub decay_rate: u64,        // how much the rate decreases per step
    pub min_rate: u64,          // floor rate (won't go below this)
    pub last_update: i64,       // last timestamp/epoch update
    pub epoch_length: i64,      // how long each step is
    pub bumps: u8,              // for PDA if used
}


initial_rate: Starting emission rate (e.g., tokens per epoch)

decay_rate: Amount subtracted from the rate each interval

min_rate: Minimum reward rate floor

last_update: Last timestamp/epoch when rewards were calculated

epoch_length: Duration between emission updates

2)ï¸âƒ£ Instruction to Initialize the Schedule
pub fn init_emission_schedule(
    ctx: Context<InitEmission>,
    initial_rate: u64,
    decay_rate: u64,
    min_rate: u64,
    epoch_length: i64,
) -> Result<()> {
    let schedule = &mut ctx.accounts.schedule;
    schedule.initial_rate = initial_rate;
    schedule.decay_rate = decay_rate;
    schedule.min_rate = min_rate;
    schedule.last_update = Clock::get()?.unix_timestamp;
    schedule.epoch_length = epoch_length;
    Ok(())
}

#[derive(Accounts)]
pub struct InitEmission<'info> {
    #[account(init, payer = authority, space = 8 + std::mem::size_of::<EmissionSchedule>())]
    pub schedule: Account<'info, EmissionSchedule>,
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}


This creates a schedule account you can reference later when calculating rewards.

ğŸ” Reward Calculation Function

Hereâ€™s a utility function to compute the current reward rate based on time since the last update, tapered by decay:

// Compute current emission rate based on elapsed time
pub fn current_emission_rate(
    schedule: &mut EmissionSchedule,
    now_ts: i64,
) -> u64 {
    let elapsed = now_ts - schedule.last_update;
    // how many epochs passed
    let steps = (elapsed / schedule.epoch_length) as u64;

    // calculate the tapered rate
    let base = schedule.initial_rate.saturating_sub(schedule.decay_rate.saturating_mul(steps));
    let new_rate = std::cmp::max(base, schedule.min_rate);

    // update last_update if needed
    if steps > 0 {
        schedule.last_update = now_ts;
    }
    new_rate
}


This:
âœ” Measures how many epochs have passed since the last emission update
âœ” Decreases the rate by decay_rate * steps
âœ” Ensures it never goes below min_rate
âœ” Updates the scheduleâ€™s timestamp

ğŸ§  Tying This Into Your Rewards Logic

To include this in your reward distribution (e.g., in your claim_rewards or unstake instruction), youâ€™d fetch the schedule and call the function before minting the reward:

pub fn distribute_rewards(ctx: Context<DistributeRewards>) -> Result<()> {
    let schedule = &mut ctx.accounts.schedule;
    let now_ts = Clock::get()?.unix_timestamp;
    let rate = current_emission_rate(schedule, now_ts);

    // Example: user_reward = rate * user_staked_amount / pool_total
    let user_amount = ctx.accounts.user_stake.amount;
    let reward = rate.saturating_mul(user_amount);

    // Mint reward tokens using CPI to SPL Token program
    let cpi_accounts = anchor_spl::token::MintTo {
        mint: ctx.accounts.mint.to_account_info(),
        to: ctx.accounts.user_ata.to_account_info(),
        authority: ctx.accounts.schedule.to_account_info(), // PDA or signer
    };
    let cpi_program = ctx.accounts.token_program.to_account_info();
    let signer_seeds = &[b"emission", &[ctx.accounts.schedule.bumps]];
    let signer = &[&signer_seeds[..]];

    anchor_spl::token::mint_to(
        CpiContext::new_with_signer(cpi_program, cpi_accounts, signer),
        reward,
    )?;

    Ok(())
}


Important: This example uses a PDA or schedule account as authority for minting via a PDA signer. Youâ€™ll need to define the proper seeds for that in your IDL.

ğŸ§  Optional: Activity-Based Adjustments

You can extend this schedule to scale rewards with activity (e.g., conversions, compute contributions) by adding multipliers:

let multiplier = calculate_activity_multiplier(ctx.accounts.user_activity);
let adjusted_rate = rate.saturating_mul(multiplier);


This lets you reward nodes with high contribution more than passive stakers.

ğŸ§  Why This Works

âœ” Dynamic Emissions: You start high and taper over time, paralleling sustainable tokenomics practices. 
Blockchain App Factory

âœ” Inflation Control: By capping at min_rate, you avoid runaway emissions that devalue the token. 
OKX

âœ” Governance Ready: You can expose schedule parameters to governance, allowing holders to adjust incentives over time.
âœ” Modular: Works with staking, conversion contributions, or other reward models.

ğŸ“Œ Practical Notes
ğŸ“… Epochs vs Timestamps

Use Solanaâ€™s Clock sysvar to get reliable timing.

You can define â€œepochsâ€ as fixed time intervals (e.g., daily, weekly).

ğŸ” Security

Use a PDA as the mint authority so rewards cannot be minted by a keypair.

Anchorâ€™s init_if_needed and account constraints reduce mistakes. 
anchor-lang.com

ğŸ§ª Automation

For fully automated periodic emissions, you can integrate on-chain schedulers like Clockwork to trigger distribution at intervals. 
solana.stackexchange.com
