eb UI: Connecting React/Next.js to Your Anchor Program (Stake/Reward)

This UI approach includes:

‚úÖ Wallet connection via Solana Wallet Adapter
‚úÖ Signing and sending transactions to your Anchor program
‚úÖ Displaying on-chain data (balances, stake, rewards)

üìå Core Concepts

You must wrap your UI with a wallet context (ConnectionProvider, WalletProvider, WalletModalProvider).

Use Anchor‚Äôs TypeScript client (based on @coral-xyz/anchor) to *
call your on-chain program*.

Use React components to show balances and buttons for stake/claim/unstake. 
Solana

1Ô∏è‚É£ Install Dependencies
npm install @solana/web3.js \
            @solana/wallet-adapter-base \
            @solana/wallet-adapter-react \
            @solana/wallet-adapter-react-ui \
            @solana/wallet-adapter-wallets \
            @coral-xyz/anchor


This includes Solana web3, Wallet Adapter, and the Anchor client for frontend interaction. 
Solana

2Ô∏è‚É£ Wallet Context Provider (React)

Create a context provider so your whole app can access wallet and connection state:

// WalletProvider.tsx
"use client";

import React, { useMemo } from "react";
import {
  ConnectionProvider,
  WalletProvider,
} from "@solana/wallet-adapter-react";
import { WalletAdapterNetwork } from "@solana/wallet-adapter-base";
import {
  PhantomWalletAdapter,
  SolflareWalletAdapter,
} from "@solana/wallet-adapter-wallets";
import { WalletModalProvider } from "@solana/wallet-adapter-react-ui";
import "@solana/wallet-adapter-react-ui/styles.css";
import { clusterApiUrl } from "@solana/web3.js";

export default function SolanaWalletProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  const network = WalletAdapterNetwork.Devnet;
  const endpoint = useMemo(() => clusterApiUrl(network), [network]);
  const wallets = useMemo(
    () => [new PhantomWalletAdapter(), new SolflareWalletAdapter()],
    [network]
  );

  return (
    <ConnectionProvider endpoint={endpoint}>
      <WalletProvider wallets={wallets} autoConnect>
        <WalletModalProvider>{children}</WalletModalProvider>
      </WalletProvider>
    </ConnectionProvider>
  );
}


Wrap your app (e.g., in layout.tsx or _app.tsx) with this provider so all pages get access to the wallet. 
Solana

3Ô∏è‚É£ Anchor Client Helper

Create a utility to load your Anchor program client using the IDL:

// anchor.ts
import * as anchor from "@coral-xyz/anchor";
import idl from "./idl/dacit_program.json";  // Your Anchor IDL

export const getProvider = (wallet: any) => {
  const connection = new anchor.web3.Connection(
    "https://api.devnet.solana.com",
    "confirmed"
  );
  const provider = new anchor.AnchorProvider(connection, wallet, {});
  anchor.setProvider(provider);
  return provider;
};

export const getProgram = (wallet: any) => {
  const provider = getProvider(wallet);
  return new anchor.Program(idl as any, idl.metadata.address, provider);
};


This makes it easy to call your program instructions (stake/claim/unstake) from the frontend.

4Ô∏è‚É£ React UI: Connect Wallet + Display Info
üü© Connect Wallet Button
import { WalletMultiButton } from "@solana/wallet-adapter-react-ui";

export function ConnectWallet() {
  return <WalletMultiButton className="btn btn-primary" />;
}


This is the standard UI component from Solana Wallet Adapter that lets users connect/disconnect. 
Solana

5Ô∏è‚É£ React Hooks to Call Your Program

Example component to stake tokens:

import { useWallet, useConnection } from "@solana/wallet-adapter-react";
import * as anchor from "@coral-xyz/anchor";
import { PublicKey } from "@solana/web3.js";
import { getProgram } from "@/utils/anchor";

export function StakeButton({ amount }: { amount: number }) {
  const { connection } = useConnection();
  const wallet = useWallet();

  const handleStake = async () => {
    if (!wallet.publicKey) return alert("Connect wallet!");

    const program = getProgram(wallet);

    try {
      await program.methods
        .stakeTokens(new anchor.BN(amount))
        .accounts({
          stakeState: /* PDA stake account */,
          user: wallet.publicKey,
          userTokenAccount: /* user ATA for DACIT */,
          vaultTokenAccount: /* program vault ATA */,
          tokenProgram: anchor.web3.TOKEN_PROGRAM_ID,
        })
        .rpc();
      alert("Staked!");
    } catch (error) {
      console.error(error);
      alert("Stake failed");
    }
  };

  return (
    <button
      onClick={handleStake}
      className="bg-indigo-500 text-white px-4 py-2 rounded"
    >
      Stake {amount}
    </button>
  );
}


You‚Äôll need to fill in the PDAs and token account addresses generated by your program. You can derive them via Anchor PDAs or use a client side helper.

6Ô∏è‚É£ Claim Rewards Button
export function ClaimRewardsButton() {
  const { connection } = useConnection();
  const wallet = useWallet();

  const handleClaim = async () => {
    if (!wallet.publicKey) return alert("Connect wallet!");

    const program = getProgram(wallet);

    try {
      await program.methods
        .claimRewards()
        .accounts({
          emissionSchedule: /* schedule PDA */,
          stakeState: /* stake state PDA */,
          mint: /* DACIT token mint address */,
          userTokenAccount: /* user ATA */,
          tokenProgram: anchor.web3.TOKEN_PROGRAM_ID,
        })
        .rpc();
      alert("Rewards claimed!");
    } catch (error) {
      console.error(error);
      alert("Claim failed");
    }
  };

  return (
    <button className="bg-green-500 text-white rounded px-4 py-2" onClick={handleClaim}>
      Claim Rewards
    </button>
  );
}


This sends a transaction to your on-chain program to mint rewards based on your emission schedule.

7Ô∏è‚É£ Unstake UI Component

Similar to stake/claim:

export function UnstakeButton() {
  const { connection } = useConnection();
  const wallet = useWallet();

  const handleUnstake = async () => {
    if (!wallet.publicKey) return alert("Connect wallet!");

    const program = getProgram(wallet);

    try {
      await program.methods
        .unstakeTokens()
        .accounts({
          emissionSchedule: /* schedule PDA */,
          stakeState: /* stake state PDA */,
          user: wallet.publicKey,
          userTokenAccount: /* user ATA */,
          vaultTokenAccount: /* program vault ATA */,
          tokenProgram: anchor.web3.TOKEN_PROGRAM_ID,
        })
        .rpc();
      alert("Unstaked!");
    } catch (error) {
      console.error(error);
      alert("Unstake failed");
    }
  };

  return (
    <button className="bg-yellow-500 text-white rounded px-4 py-2" onClick={handleUnstake}>
      Unstake
    </button>
  );
}

8Ô∏è‚É£ Display On-Chain Data

After transactions, show user balance, stake amount, and pending rewards:

export function UserInfo() {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [balance, setBalance] = useState(0);

  useEffect(() => {
    if (!wallet.publicKey) return;

    connection.getBalance(wallet.publicKey).then(setBalance);
  }, [wallet.publicKey]);

  return (
    <div className="p-4 text-gray-800">
      <p>Wallet: {wallet.publicKey?.toBase58()}</p>
      <p>SOL Balance: {balance / anchor.web3.LAMPORTS_PER_SOL}</p>
    </div>
  );
}


You can easily extend this to fetch token account balances using connection.getTokenAccountsByOwner(...). 
Quicknode

üìå Responsive UI Organization

Use Tailwind utility classes for dashboard layout:

<div className="p-6 grid grid-cols-1 md:grid-cols-2 gap-6">
  <UserInfo />
  <StakeButton amount={1000} />
  <ClaimRewardsButton />
  <UnstakeButton />
</div>

üß† Tips & Best Practices

üîπ Always wrap your UI with Solana Wallet context providers. 
Solana

üîπ Use Anchor‚Äôs getProgram() wrapper to cleanly interact with your on-chain program.
üîπ Validate PDAs and token account addresses ‚Äî mismatches lead to transaction errors.
üîπ Consider adding pending/loading UI state (e.g., spinners) when sending RPCs.
üîπ Test on Devnet before moving to Mainnet.
